# [快速幂](https://leetcode.cn/problems/powx-n/)

![image-20250417110858285](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250417110858400.png)

## 算法原理

解法一: 从一到`n`的循环或者递归.   但有个问题, 就是因为`n`的次数太大, 所以可能会超时或者栈溢出

解法二: 快速幂, 这是一个小的专题算法, 仍然分为递归和循环两种, 

我们这里只是略微提一下循环的方式, 循环的方式就是把指数以二进制的方式拆开, 比如说13是1101, 那对应的值其实就是8 4 1, 然后我们从底数的一次方开始, 每次自己乘自己, 这样就相当于变成底数的二次方, 四次方, 八次方, 然后这些一次方, 二次方, 四次方, 八次方就能和1101的最低位, 次低位, 从右往左第三位, 最高位一一对应. 然后连着乘就行了.

循环的方式也是拆分, 但不是用二进制的形式拆分, 比如对于`2^16`, 可以拆成`2^8 * 2^8`, 而如果求`2^8`, 又可以拆成`2^4 * 2^4`, , 接着是`2^2`, `2^1`, `2^0`

如果指数是奇数, 那就最后再乘一个自己就行了.

函数声明格式, 可以直接用力扣给的, 而对于函数体, 我们先求出`tmp = pow(x, n / 2)`, 最后的返回值分情况表示, 如果是偶数, 那结果就是`tep * tmp`, 如果是奇数, 那结果是`tmp * tmp * x`, 边界条件是`n == 0 , return 1;`

接下来我们处理一些细节问题, 首先指数`n`可能是负数的, 此时`return 1 / pow(x, -n)`, 其次, `n`取负数后可能会溢出, 因为`n`可以是`int`最小值, 所以我们要先把`n`转成`long long`再取负数.

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        return n < 0 ? 1 / pow(x, -(long long)n) : pow(x, n);
    }

    double pow(double x, long long n)
    {
        if(n == 0) return 1;
        if(n == 1) return x;
        double temp = pow(x, n / 2);
        // 这种写法必须写 `n == 1`边界条件,, 否则会栈溢出
        return temp * temp * pow(x, n % 2);
        // 这个可以不写 n == 1
        // return n % 2 ? temp * temp * x : temp * temp;
    }
};
```


# [斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

![image-20250427114333142](https://raw.githubusercontent.com/ListenStarsWind/images/master/2025/20250427114333224.png)

## 算法导入

关于斐波那契数列, 是我们学习各种编程思想的常客. 它的解法多种多样, 包括但不限于循环, 递推, 递归, 动规, 以及我们现在所说的记忆化搜索. 

我们先使用递归来解决一下这道题. 因为记忆化搜索是建立在递归上的.

```cpp
class Solution {

    int dfs(int n)
    {
        if(n == 0 || n == 1) return n;

        return dfs(n-1) + dfs(n-2);
    }

public:
    int fib(int n) {
        return dfs(n);
    }
};
```

我们看到提交记录的时间花费比较不理想, 让我们来分析一下它为什么不理想, 假设`n == 5`, 此时就有

我们发现这里面有非常多重复的部分
![image-20250427130733833](https://raw.githubusercontent.com/ListenStarsWind/images/master/2025/20250427130734030.png)

那么, 我们想一下, 能不能把每次返回的数据存到一个数据结构之中, 那等到下次又遇到这个参数, 那我就不用再展开子树了, 而是直接用数据结构里面的值.比如我们深搜第一次遇到`d(3)`的时候, 那就存一下, 等到第二次遇到`d(3)`, 就可以直接进行复用, 并且, 由于整个逻辑是递归的, 所以对于`d(3)`的两个子树`d(1), d(2)`来说, 它们也可以直接用之前存的值

![image-20250427131815052](https://raw.githubusercontent.com/ListenStarsWind/images/master/2025/20250427131815151.png)

最后剩下的其实几乎就是一个链表, 从而将时间复杂度由指数级别降到线性级别.  我们可以把这个数据结构叫做备忘录

记忆化搜索的代码可以在递归上直接改

- 递归返回时, 把返回值放到备忘录里

  ```cpp
  class Solution {
  
      // 这里比较简单, 所以直接用数组映射
      vector<int> memo;   // 备忘录的常见写法"memory", 意为记忆
  
      int dfs(int n)
      {
          if(n == 0 || n == 1)
          {
              memo[n] = n;
              return memo[n];
          }
  
          memo[n] = dfs(n-1) + dfs(n-2);
          return memo[n];
      }
  
  public:
      int fib(int n) {
          // 让递归参数和返回值产生映射关系
          // -1表示第一次
          memo.resize(n+1, -1);
          return dfs(n);
      }
  };
  ```

- 如果之前已经记录过了, 那就直接返回

  ```cpp
  class Solution {
  
      // 这里比较简单, 所以直接用数组映射
      vector<int> memo;   // 备忘录的常见写法"memory", 意为记忆
  
      int dfs(int n)
      {
          if(memo[n] != -1)
              return memo[n];
  
          if(n == 0 || n == 1)
          {
              memo[n] = n;
              return memo[n];
          }
  
          memo[n] = dfs(n-1) + dfs(n-2);
          return memo[n];
      }
  
  public:
      int fib(int n) {
          // 让递归参数和返回值产生映射关系
          // -1表示第一次
          memo.resize(n+1, -1);
          return dfs(n);
      }
  };
  ```

## 动态规划和记忆化搜索

接下来我们用动态规划解一下这道题.

- **状态表示**

  定义`dp[n]`表示第`n`项(从零开始)的值

- **状态转移**

  题目已经直接告诉过我们了, `dp[n] = dp[n-1] + dp[n-2]`

- **初始化**

  为了避免越界, 要先对`dp[0], dp[1]`进行初始化

- **填表顺序**

  从左到右

- **返回值**

  `dp[n]`

然后我们其实可以发现, 在本题中, 状态表示其实就是递归函数的宏观作用, 状态转移就是递归函数的函数体, 初始化是递归的出口, 填表顺序是填写备忘录的顺序, 或者说深搜的顺序, 返回值是树的根节点.

它们两个一一对应的原因是, 动态规划和记忆化搜索的本质都是 穷举, 也就是暴力解法, 或者说暴搜., 为了`n`项的值, 需要把前面的项都算一下., 并存起来. 然后后面直接用之前存的值.

```cpp
class Solution {
public:
    int fib(int n) {
        vector<int> dp(n+1);
        if(n >= 1) dp[1] = 1;
        for(int i = 2; i <= n; ++i)
            dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
};
```

## 其它

下面我们回答一些问题:

所有的递归(暴搜, 深搜)都能改成记忆化搜索吗?    答案并不是, 只有完全相同的问题, (递归本身是类型的子问题, 如果参数相同, 才是完全相同的问题), 如果一个递归的逻辑是这样的, 
![image-20250427142238423](https://raw.githubusercontent.com/ListenStarsWind/images/master/2025/20250427142238502.png)

只有在出现大量完全相同的子问题时才推荐使用记忆化搜索

带备忘录的递归, 带备忘录的动态规划, 这两种说法其实指的就是记忆化搜索

辨析自顶向下和自底向上.   方向不同, 一个是为了第`5`项去求第`4`项和第`3`项, 一个是从第`2`项开始, 去求第`3`项., 其实分别就对应着记忆化搜索和普通的动态规划.

在上面的过程中, 我们用暴搜推出了记忆化搜索, 然后可以用记忆化搜索改成动规. 这种思路可行吗? 基本可行, 百分之80到百分之90都可以, 但对于某些题来说, 由于过程比较复杂, 所以暴搜会非常难写, 比如股票问题的暴搜. 递归出口不好定, 要写几个递归函数, 要有多个备忘录.  对于这种思路, 视情况而定.

另外, 记忆化搜索其实可以认为已经是动态规划了, 不需要刻意再转化成动态规划.

# 完